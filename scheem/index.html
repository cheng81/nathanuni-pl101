<html>
<head>
<title>Scheem playground</title>
<link rel="stylesheet" href="../css/codemirror.css"/>
<link rel="stylesheet" href="../css/monokai.css"/>
<style type="text/css">
	body {
	  font-family: Droid Sans, Arial, sans-serif;
	  line-height: 1.5;
	  margin: 3em auto;
	  padding: 0 1em;
	}

	h1 {
	  letter-spacing: -3px;
	  font-size: 3.23em;
	  font-weight: bold;
	  margin: 0;
	}
	input#submit {
		width: 100%;
		border: solid 2px #000;
		margin: 0;
		padding: 0;
		font-variant: small-caps;
		font-weight: bold;
	}
/*	div#result {
		margin-top: 1em;
	}*/
	div#examples {
		display: none;
	}

	div#main {
		float: left;
		width: 70%;
	}
	div#result {
		width: 25%;
		float:left;
		margin-left: 1em;
		background-color: #efefef;
	}
</style>
<!--<script type="text/javascript" src="https://raw.github.com/cheng81/nathanuni-pl101/master/lesson5/dist/scheem.js"></script>-->
<!--<script type="text/javascript" src="../../nathanuni-pl101/lesson5/dist/scheem.js"></script>-->

<script type="text/javascript" src="../js/jquery-1.7.2.min.js"></script>
<script type="text/javascript" src="../js/codemirror.js"></script>
<script type="text/javascript" src="../js/scheme.js"></script>
<script type="text/javascript">

$(document).ready(function() {
	var toload = window.location.protocol==='file:' ?
	"../../nathanuni-pl101/lesson5/dist/scheem.js" :
	"https://raw.github.com/cheng81/nathanuni-pl101/master/lesson5/dist/scheem.js";
	var head = document.getElementsByTagName('head')[0];
	var script = document.createElement('script');
	script.type = "text/javascript";

	var require = null;
	var scheem = null;
	console.log('toload',toload);
	script.onload = function() {
		console.log('scheem loaded');
		require = window.node2browser.require;
		scheem = require('scheem');	
	}
	script.src = toload;
	head.appendChild(script);


	var srcArea = $('textarea#source')[0];
	var outDiv = $('div#result');

	var lastChange = -1;
	var eventualEval = function() {
		if(lastChange>0) {window.clearTimeout(lastChange);}
		lastChange = window.setTimeout(function() {
			console.log('goeval');
//			try {
				var out = scheem.make(myCodeMirror.getValue());
				var html = '';
				if(out.result) {
					html = JSON.stringify(out.result);
					console.log(out.ast);
				} else {
					html = out.error.name + ':' + out.error.message;
				}
				$(outDiv).html(html);
//			} catch(e) {console.log(e);}		
		},1500);
	};
	var myCodeMirror = CodeMirror.fromTextArea(srcArea, {
		lineNumbers: true,
		theme: 'monokai',
		onChange: function() {
			eventualEval();
		}
	});


	var btns = $('p.examples-btn');
	$('div#examples > div').each(function(idx,div) {
		var theid = div.id;
		$(btns).append('<input type="button" id="load-'+theid+'" value="'+theid+'"/>');
		$('input#load-'+theid).click(function(e) {
			e.preventDefault();
			myCodeMirror.setValue($(div).text());
			return false;
		});
	});
});
</script>
</head>
<body>
<h1>Scheem live</h1>
<div id="container">
	<p class="examples-btn">
	</p>
	<div id="main">
	<textarea id="source">
;; type some scheem source, results will be shown here ------>
;; or click one of the button above, to load some predefined examples
</textarea>
	<!--<input type="button" value="Run" id="submit"/>-->
	</div>
	<div id="result">&nbsp;</div>
</div>
<div style="clear:both">&nbsp;</div>

<div id="examples">
	<div id="map">(defun map (fn lst)
       (match lst
              ( (cons x xs) (cons (fn x) (map fn xs)) )
              ( _ '())))

(map (+ 1) (list 1 2 3))</div>
	<div id="curry">(define plusser
  (lambda (x y)
    (+ x y)))
(define plus5 (plusser 5))
(define plus1 (plusser 1))
(plus5 (plus1 3))</div>
	<div id="fibonacci">;;demostration of some sugaring stuff

;;first, no sugar at all,
;;plain define+lambda+nested if
(define fibns
  (lambda (n)
    (if (= n 0)
        1
        (if (= n 1)
            1
            (+ 
             (fibns (- n 1)) 
             (fibns (- n 2)))))))

;;let's improve,
;;defun is a sugar
;;(defun <name> <args> <body>)
;;(define <name> (lambda <args> <body>))
;;cond is also sugar, that basically boils down
;;to a nested if
;;(cond (<c1> <b1>)...(else <b_n>))
;;(if <b1> <c1> (if <b2> <c2> (... (if <c_n-1> <b_n-1> <b_n>)) ))
(defun fibc (n)
       (cond
        ((= n 0) 1)
        ((= n 1) 1)
        (else (+ 
               (fibc (- n 1)) 
               (fibc (- n 2))))))

;;let's try something different
;;but I'll not explain the match
;;construct..it's a bit of a mess
(defun fibm (n)
       (match n
              (0 1)
              (1 1)
              (x (+ 
                  (fibm (- x 1)) 
                  (fibm (- x 2))))))

(list (fibns 5) (fibc 5) (fibm 5))</div>
	<div id="lookup-env">(defun*
 (lookup (key dict)
         (cond
          ((empty? dict) (error 'empty-dict))
          ((= key (car dict)) (nth 1 dict))
          (else (lookup key (nth 2 dict)))))
 (insert (key value dict)
         (list key value dict)))

(define d '())
(set! d (insert 'foo 5 d))
(set! d (insert 'bar 5 d))
(define foo1 (lookup 'foo d))
(set! d (insert 'foo 10 d))
(define foo2 (lookup 'foo d))
(list foo1 foo2)</div>
	<div id="fold">(defun empty? (x)
       (=l x '()))

(defun fold (fn accum lst)
       (match lst
              ( (cons x xs) (fold fn (fn accum x) xs))
              ( _ accum)))

(fold + 0 '(1 2 3 4))</div>
	<div id="stdlib">;; functions defined in std library
;; there is also de-cons, but that's
;; used in the context of pattern matching
(list
 ((id 5))
 (empty? '())
 (empty? '(1 2))
 (map (* 2) '(1 2 3))
 (reverse '(1 2 3))
 (append '(1 2) '(3 4))
 (nth 1 '(a b c))
 (match '(1 2)
        ( (cons x xs) x) ;;here, cons is de-sugard to a call to de-cons(list continuation failure) function
        ( '() 'empty)))</div>
	<div id="mutual-recursive">(defun*
 (even? (x) (if (= x 0) #t (odd? (- x 1))))
 (odd?  (x) (if (= x 0) #f (even? (- x 1)))))

(defun countEven (lst)
       (fold + 0 (map (lambda (x) (if x 1 0)) (map even? lst))))

(countEven '(1 2 3 4 5 6 7 8))</div>
	<div id="expr-eval">(defun lookup (k env)
	(if (empty? env)
			(error 'undef-val)
			(if (= k (nth 0 env))
				(nth 1 env)
				(lookup k (nth 2 env)))))

(defun define-env (env k v)
	(list k v env))

(defun eval (expr env)
	(begin
	(cond
		( (int? expr) expr )
		( (bool? expr) expr )
		( (sym? expr) (lookup expr env) )
		( else
			(match (car expr)
				( '+ (+ (eval (nth 1 expr) env) (eval (nth 2 expr) env)) )
                ( '= (= (eval (nth 1 expr) env) (eval (nth 2 expr) env)) )
				( 'if (if (eval (nth 1 expr) env)
					(eval (nth 2 expr) env)
					(eval (nth 3 expr) env) ) )
				( 'let (eval (nth 2 expr) (define-env env (nth 0 (nth 1 expr)) (nth 1 (nth 1 expr)))) )
				( 'begin (fold (lambda (_res sub) (eval sub env)) 0 (cdr expr)))
				( 'alert (alert (eval (nth 1 expr) env)) )
				( _ (alert expr) )
			) )
		)))

(eval
'(begin
	(let (x 1)
	(if (= x 2) 2 3)))
'())</div>
</div>
</body>
</html>